I"¬<p>With Pandas, exploring datasets is a game.   <br />
First I copy my Dataframe. That way I always have a clean copy. 
I start slowly with <code class="language-plaintext highlighter-rouge">pd.info()</code>, <code class="language-plaintext highlighter-rouge">pd.describe()</code> and finally a <code class="language-plaintext highlighter-rouge">pd.head()</code>. With <code class="language-plaintext highlighter-rouge">pd.shape</code> I stay on Python or switch to Spark and that‚Äôs another story.
Let‚Äôs go a bit further, <code class="language-plaintext highlighter-rouge">df.nunique()</code> to count the number of unique values in a column and then <code class="language-plaintext highlighter-rouge">df[df.duplicated(keep=False)].sort_values("one_value")</code>. I look for duplicate rows, I want them all sorted and grouped by ‚Äúone value‚Äù.</p>

<p>Then I create a smaller Dataframe according to a criterion. For example, I want to create a smaller dataframe, 
<code class="language-plaintext highlighter-rouge">cols = [col for col in n_df.columns if n_df[col].isnull().any()]; df_miss = n_df[cols]</code> to get a new Dataframe with only the columns containing the missing data. And <code class="language-plaintext highlighter-rouge">df_miss.isna().sum()</code> to continue exploring this smaller Dataframe.</p>

<p>By taking a value(‚ÄúUS-HI‚Äù), we find it if it exists with 
<code class="language-plaintext highlighter-rouge">df[df.apply(lambda x: x.astype(str).str.contains(r'\bUS-HI\b')).any(axis=1)]</code>. For the whole data frame, if the type is <code class="language-plaintext highlighter-rouge">str</code>, check that it contains exactly ‚ÄúUS-HI‚Äù for any value in the column. The return is a Dataframe with the rows that contain this string.</p>

<p>And don‚Äôt forget <code class="language-plaintext highlighter-rouge">%xdel</code> to delete unnecessary Dataframes.</p>

<p>Tomorrow, I will work about data clean‚Ä¶ One more time! <br />
So, step by step!</p>
:ET